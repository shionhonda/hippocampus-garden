---
title: 書評『コンピュータの構成と設計』
date: "2025-05-24T22:12:03.284Z"
description: "『コンピュータの構成と設計』（通称「パタヘネ本」）のまとめと感想です。"
featuredImage: book_review_patterson/ogp.jpg
tags: ["ja", "book"]
---

『[コンピュータの構成と設計 第6版](https://amzn.to/4kfaUik)』（David Patterson, John Hennessy 著、成田光彰 訳、日経BP、2021年）、通称「パタヘネ本」を読んだので、内容と感想をまとめます。

本書は、現代のコンピュータの動作原理をハードウェアレベルから丁寧に解説してくれる定番教科書です。時代の変化に合わせて頻繁に改訂されており、今回の第6版では、ドメイン固有アーキテクチャや クラウドコンピューティングといったトピックが追加されています。

## 総評

ハードウェアの知識が乏しく、CPUがどう命令を実行しているのか曖昧なままソフトウェアを書いてきた私にとって、本書は難しいながらも非常に有意義でした。ソフトウェアが動く基盤としてのハードウェアの構成、命令の形式、計算の仕組み、記憶階層や並列処理の考え方が、豊富な図と明快な文体で語られています。

一般的なソフトウェアエンジニアにとって、明日から仕事で使える知識が身に付くという類の本ではありませんが、低レイヤへの理解を深めたい人にとっては間違いなく読む価値のある一冊でしょう。個人的には機械学習に携わる人間として、深層学習になぜGPUやTPUが必要なのかを理解するための基礎知識が得られたのが大きな収穫でした。

定番教科書ということで練習問題やコラムが豊富に用意されていますが、私は読み飛ばしてしまいました。実際に手を動かすと、さらに理解が深まることでしょう。

## 内容のまとめ

以下、各章の主要な概念とその背景をまとめていきます。

### 第1章 コンピュータの抽象化とテクノロジー

この章では、コンピュータ設計における7つの設計原理を通じて、複雑なハードウェア設計をどう合理化し、性能と信頼性を両立させてきたかが語られます。以下に、それぞれの原理を示します。

1. 抽象化：下位の詳細を隠して上位レベルの設計を単純化します。
2. 一般的な場合の高速化：よく使われる処理を特に速くすることで全体の性能を引き上げます。
3. 並列処理：複数の命令を同時に実行することでスループットを向上させます。
4. パイプライン処理：命令を分割して連続的に処理することで実行効率を高めます。
5. 予測実行：分岐を予測して先に処理を進め、待機時間を削減します。
6. 記憶階層の活用：速度と容量の違うメモリを階層構造で使い分けて最適化します。
7. 冗長性による信頼性の確保：複製や予備を用いて障害に備え、システムを安定させます。

また、**トランジスタ**というミクロな構成要素が**集積回路**（integrated circuit; **IC**）として数百万単位でチップに集約され、さらには**超大規模集積回路**（very large-scale integration; **VLSI**）として機能する過程が示されます。ここで登場する**Mooreの法則**は、半導体産業における性能・コストの進化を象徴する概念であり、設計者がどのような期待と制約のもとで開発を行ってきたかを知る手がかりとなります。

### 第2章 命令：コンピュータの言葉

コンピュータはすべての処理を**命令**（**instruction**）の実行として捉えます。命令は、特定の演算やデータ操作を記述した最小単位であり、それらを体系化したものが**命令セットアーキテクチャ**（instruction set architecture; **ISA**）です。

本書では、教育目的で設計された**MIPS命令セット**を使用して、コンピュータの基本的な命令の仕組みを学びます。MIPSは命令の種類が少なく、命令形式が整っているため、アーキテクチャの理解を深めるのに最適です。

ISAには以下のような命令が含まれます：

* **データ転送命令**（メモリとレジスタ間のデータの読み書き）
* **算術命令**（加減乗除などの基本演算）
* **論理命令**（AND, OR, NOT などのビット演算）
* **条件分岐命令**（if文に相当、条件に応じてジャンプ）
* **ジャンプ命令**（無条件に次の命令を変更）

MIPSアーキテクチャでは、32個の32ビットレジスタがあり、CPU内で非常に高速にアクセスできます。演算対象となるデータ（**オペランド**）は主にこれらのレジスタに格納されます。32ビットという単位は、1ワード（word）と呼ばれます。より大きなデータや動的に確保された変数は**メモリ**に格納され、プログラム中でポインタを通じてアクセスします。

CPU内部では、数値はすべてビット列として扱われます。MIPSでは、基本的に32ビット整数を採用しており、次の2つの型が使われます：

* **符号なし整数**：0 ~ 2^32-1
* **符号付き整数**：-2^31 ~ 2^31-1（**2の補数表現**を使用）

この範囲を超える結果が出た場合、**オーバーフロー**が発生し、予期しない動作になることがあります。

MIPSの命令はすべて**32ビット固定長**で、次のようなフォーマットに従って構成されます（R形式の例）：

* **opcode**：命令の種類を表す6ビット
* **rs/rt/rd**：ソースおよび宛先レジスタの指定（各5ビット）
* **shamt**：シフト量（5ビット）
* **funct**：詳細な演算指定（6ビット）

命令は通常、16進数（hexadecimal）で表現され、これにより人間が読んで理解しやすくなります。

ソースコードがCPUにより実行されるまでには、以下の段階を経ます：

1. **コンパイル**：Cなどの高水準言語から中間表現（アセンブリ）への変換
2. **アセンブル**：アセンブリ言語を機械語に変換（オブジェクトファイルを生成）
3. **リンク**：複数のオブジェクトファイルやライブラリを結合し、1つの実行ファイルに
4. **ロード**：実行時にOSがファイルをメモリに展開し、CPUが処理を開始

### 第3章 算術演算：ビットの世界の計算

この章では、コンピュータがどのように数値を扱うか、その根幹である**算術演算**の仕組みを詳しく学びます。この部分は大学の講義なので履修済みの方も多いのではないかと思います。

最も基本的な演算は加算と減算で、これらは桁ごとの繰り上がり（carry）や繰り下がり（borrow）を考慮してビット単位で処理されます。減算は、2の補数を使って加算として処理されるのが一般的で、CPU内部の加算器をそのまま利用できます。

乗算は加算を繰り返す方法で理論的には実現できますが、実際のハードウェアではシフト演算と加算を組み合わせた高速なアルゴリズムが使われます。除算はより複雑で、0除算などの例外に備えた制御も必要になります。結果は「商」と「余り」に分けて扱われます。

整数だけでは表現できない実数を扱うために、**浮動小数点数**が用いられます。数値は以下の3つで構成されます：

1. **符号**（sign）：数が正か負かを示す1ビット
2. **指数部**（exponent）：数のスケール（桁の大きさ）を表す
3. **仮数部**（significand）：実際の有効桁を保持する

この構造により、非常に大きな数も非常に小さな数も効率よく表現可能です。32ビットでは単精度、64ビットでは倍精度と呼ばれ、用途に応じて使い分けられます。

浮動小数点演算では、計算結果が表現できる範囲を超えると**オーバーフロー**や**アンダーフロー**（ゼロに丸められる）が発生します。これらを防ぐために、演算の前にスケーリングや範囲チェックを行うことが重要です。

### 第4章 プロセッサの構成とパイプライン

プロセッサは、以下のような要素から構成されます：

* **プログラムカウンタ**（program counter; **PC**）：次に実行する命令のメモリアドレスを保持します。
* **命令デコーダ**：命令のビット列を解釈し、操作に必要な制御信号を生成します。
* **算術論理演算装置**(arithmetic logic unit; **ALU**)：加減算やAND、ORなどの演算を担当します。
* **レジスタファイル**：一時的なデータ保存用の高速な記憶領域です。
* **データメモリ**：変数などを格納する、より大きく遅い記憶領域です。
* **マルチプレクサ**（Multiplexer）：複数の信号から必要な入力を選択して出力します。

これらのコンポーネントは、**クロック信号**で同期され、1クロックごとに命令をステップ実行します。動作の正確性を保つため、データの読み出しと書き込みが競合しないよう、制御タイミングが極めて重要です。

プロセッサの性能向上に欠かせない技法が**パイプライン処理**です。命令を複数の段階（ステージ）に分割し、各段階を同時並行的に処理します。代表的な5ステージは以下の通りです：

1. **フェッチ（IF）**：命令メモリから命令を読み出す
2. **デコード（ID）**：命令を解釈し、必要なレジスタを読み出す
3. **実行（EX）**：ALUで演算を行う
4. **メモリアクセス（MEM）**：必要に応じてデータメモリにアクセスする
5. **ライトバック（WB）**：演算結果をレジスタに書き戻す

この仕組みによって、複数の命令が異なるステージで同時に処理されるため、1クロックごとに1命令が完了する理想的なスループットが目指せます。

パイプライン処理には効率化と引き換えに、ハザードと呼ばれる処理の停滞要因が発生します。

* **データハザード**：前の命令がレジスタを更新する前に次の命令がそれを読み出そうとする場合に発生します。
* **制御ハザード**：分岐命令の結果が分かるまで次の命令が決められない場合に生じます。
* **構造ハザード**：同一クロックで複数の命令が同じ装置を使おうとする競合です。

これらを解決するために、フォワーディングやパイプラインの一時停止、バブル挿入などの対策が取られます。

**投機実行**（speculative execution）は、制御ハザードの影響を軽減するための高度な手法です。分岐命令の結果を事前に予測し、予測が正しい前提で命令実行を進めておくことで、無駄な停止を避けます。もし予測が外れた場合は、ロールバックして正しい命令列に切り替えます。この技法は、性能向上には有効ですが、セキュリティ（例：Spectre脆弱性）への影響もあるため、近年ではその扱いに慎重さが求められています。

### 第5章 記憶階層：速度と容量の両立

この章では、コンピュータにおける**メモリシステム**の設計思想と、その性能最適化のための工夫を学びます。

局所性とは、アクセスされるデータに時間的・空間的な偏りがあるという性質で、記憶階層の設計根拠です。

* **時間的局所性**：最近使われたデータは近いうちに再利用される
* **空間的局所性**：隣接するデータも一緒にアクセスされやすい

記憶階層は、複数のメモリ技術の組み合わせで構成されます。

* **SRAM**（Static RAM）：CPUキャッシュに使われる非常に高速なメモリ。
* **DRAM**（Dynamic RAM）：主記憶として使用され、リフレッシュが必要。
* **フラッシュメモリ**：SSDなどに用いられ、書き換え可能な不揮発性。
* **HDD**（ハードディスク）：機械的な構造を持ち、容量が大きく低価格。

それぞれ、**速度・容量・価格**のトレードオフがあり、適切な組み合わせがシステム全体の効率を左右します。具体的には局所性を利用して、高速・小容量で高価なメモリをCPU近くに、低速・大容量で安価なメモリを離れた場所に配置します。

**キャッシュ**（**cache**）は、よく使われるデータを手元に保持してアクセス速度を上げる仕組みです。

* **ダイレクトマップ方式**：各メモリブロックは特定の1か所にしか格納できず、高速だが衝突が多い。
* **フルアソシアティブ方式**：任意のブロックをどこにでも格納できるが検索に時間がかかる。
* **セットアソシアティブ方式**：上記2方式の中間で、適度な柔軟性と性能を両立。

キャッシュと主記憶の一貫性を保つための書き込みポリシーとして、以下の2つが一般的です：

* **ライトスルー**：常に主記憶にも書き込み、一貫性が高いが遅い。
* **ライトバック**：キャッシュの内容だけを書き換え、置き換え時に主記憶へ反映する。

また、**ミスペナルティ**（キャッシュミス時の遅延）を抑えるために、**L1/L2/L3キャッシュ**のように、複数段階のキャッシュを設けることも一般的です。ミス率を下げる工夫には、ブロックサイズの最適化、置換アルゴリズム（例：LRU）の導入などがあります。

### 第6章 並列プロセッサと用途特化型アーキテクチャ

**マルチプロセッサ**は、複数のプロセッサコアを搭載することで、並列に処理を進め、スループットを向上させます。一方、**ハードウェア・マルチスレッディング**（hardware multithreading）では、1つのコア内で複数のスレッドを切り替えて実行することで、リソースの遊休時間を削減します。

**GPU**（graphics processing unit）は、もともと画像処理に特化して開発されたハードウェアで、現在では数千スレッド規模の並列処理が可能な汎用並列計算機として進化しています。CPUと比べて、より単純な命令を多数同時に処理できる構造を持ちます。表形式で比較すると以下のようになります。

| **特徴**  | **CPU**  | **GPU**      |
| ------- | -------- | ------------ |
| 主用途     | 汎用計算     | グラフィックス・機械学習 |
| 並列性     | 数コア      | 数千スレッド       |
| レイテンシ処理 | キャッシュで隠蔽 | スレッド切り替えで隠蔽  |
| メモリ設計   | レイテンシ最小化 | バンド幅最大化      |

Mooreの法則の鈍化に伴い、単純なトランジスタ数の増加では性能が頭打ちになってきた今、特定用途に特化した設計（domain-specific architecture; **DSA**）が注目を集めています。

DSAは、ある分野に絞ることで、以下のような最適化を行います：

1. データ転送の最小化：データを演算ユニットの近くに配置し、転送コストを抑える
2. 簡素なマイクロアーキテクチャ：複雑な制御を省略し、計算や通信に回す
3. 最適な並列性：データ並列やパイプライン並列など、用途に応じて選択
4. 精密なデータ型制御：必要なビット幅だけを使い、無駄を省く
5. 専用言語の活用：最適化しやすいプログラミングモデルを提供

Googleが開発した**TPU**（tensor processing unit）は、深層学習に特化したDSAの代表例です。行列乗算や畳み込み演算といった操作を対象に、専用のハードウェアと命令セットで構成されています。
