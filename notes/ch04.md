# Notes on Chapter 4: Implementing B-trees (Database Internals)

## Page Structure

- The page header holds information used for navigation, maintenance, and optimizations
- PostgreSQL stores page size and layout version in the header
- Some implementations store forward/backward links pointing to left and right sibling pages
- Node size and tree fanout values are fixed and don't change dynamically
  - Difficult to determine universally optimal values
- Variable-size nodes can be implemented by building nodes from multiple linked pages

## Tree Traversal

- Instead of storing parent node pointers, it's possible to track nodes traversed on the path to target leaf
- During operations that may cause structural changes, we first traverse from root to leaf
- "Breadcrumbs" contain references to nodes along the path
  - A stack is the most natural data structure for this

## Optimizations

- Some implementations postpone splits and merges to amortize costs
- Rebalancing elements within the level or moving elements between nodes improves occupancy
- B-trees can distribute data between neighboring nodes until both siblings are full
- Instead of splitting one node into two half-empty ones, the algorithm can split two nodes into three, each ⅔ full

## Compression

- Storing raw uncompressed data can be inefficient
- Many databases offer compression to save space
- Compression can be done at different granularity levels:
  - Whole-file compression offers better ratios but limited application
  - Page-wise compression fits well with fixed-size pages
  - Row-wise or column-wise compression of data only

## Deletion and Maintenance

- B-trees are navigated from the root level
- Records reachable by following pointers from the root are "live" and addressable
- Non-addressable data records are considered "garbage"
  - These records cannot be read or interpreted
- Space reclamation and page rewrites are handled by a process called:
  - Compaction
  - Vacuum
  - Maintenance

## Summary

The chapter covers concepts specific to on-disk B-tree implementation:

- Page headers
- Rightmost pointers
- High keys
- Overflow pages

It also discusses optimization and maintenance techniques:

- Rebalancing
- Write-only appends
- Bulk loading
- Garbage collection

These concepts bridge the gap between basic B-tree algorithms and real-world implementations.

# B木の実装に関する第4章のノート（データベース内部構造）

## ページ構造

- ページヘッダーはナビゲーション、メンテナンス、最適化に使用される情報を保持します
- PostgreSQLはヘッダーにページサイズとレイアウトバージョンを格納します
- 一部の実装では、左右の兄弟ページを指す前方/後方リンクを格納しています
- ノードサイズとツリーの分岐数は固定されており、動的に変化しません
  - 普遍的に最適な値を決めるのは難しいです
- 複数のリンクされたページからノードを構築することで、可変サイズのノードを実装できます

## ツリートラバーサル

- 親ノードポインタを保存する代わりに、ターゲットリーフへのパス上で通過したノードを追跡することが可能です
- 構造的変更を引き起こす可能性のある操作では、まずルートからリーフへのトラバースを行います
- 「パンくずリスト」はパス上のノードへの参照を含みます
  - スタックがこれに最も自然なデータ構造です

## 最適化

- 一部の実装では、コストを償却するために分割と結合を延期します
- レベル内での要素の再配置やノード間での要素の移動は占有率を向上させます
- B木は両方の兄弟が満杯になるまで、隣接するノード間でデータを分散できます
- 1つのノードを2つの半空のノードに分割する代わりに、��ルゴリズムは2つのノードを3つに分割し、それぞれが2/3満杯になるようにします

## 圧縮

- 生の非圧縮データを保存すると非効率的な場合があります
- 多くのデータベースは容量を節約するための圧縮機能を提供しています
- 圧縮は異なる粒度レベルで実行できます：
  - ファイル全体の圧縮はより良い圧縮率を提供しますが、応用が限られています
  - ページ単位の圧縮は固定サイズのページによく適合します
  - 行単位または列単位のデータのみの圧縮

## 削除とメンテナンス

- B木はルートレベルからナビゲートされます
- ルートからポインタをたどることでアクセス可能なレコードは「生きている」アドレス可能なものです
- アドレス不可能なデータレコードは「ガベージ」と見なされます
  - これらのレコードは読み取りや解釈ができません
- スペースの再利用とページの書き直しは以下のプロセスによって処理されます：
  - コンパクション
  - バキューム
  - メンテナンス

## 要約

この章ではディスク上のB木実装に特有の概念を扱っています：

- ページヘッダー
- 最右ポインタ
- ハイキー
- オーバーフローページ

また、最適化とメンテナンス技術についても議論しています：

- 再バランシング
- 書き込み専用追加
- 一括ロード
- ガベージコレクション

これらの概念は、基本的なB木アルゴリズムと実世界の実装の間のギャップを埋めるものです。
