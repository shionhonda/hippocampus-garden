# Chapter 7: Log-Structured Storage

## Accounting Analogy

When accountants have to modify a record, instead of erasing the existing value, they create a new recording. To derive the bottom line, you have to go through the records and calculate the subtotal. Similarly, immutable storage structures do not allow modifications to existing files; instead, they add new records.

## Mutable vs. Immutable Structures

- **Mutable (In-place updates)**: B-tree is a typical example
- **Immutable (Append-only)**: Log structures, LSM trees, and Lucene trees are examples

## Performance Trade-offs

### In-place Update Storage Structures

- Optimized for read performance
- After locating data on disk, records can be returned to the client
- This comes at the expense of write performance
- To update data, the record must first be located on disk

### Append-only Storage

- Optimized for write performance
- Writes do not have to locate records on disk to overwrite them
- This is done at the expense of reads, which have to retrieve multiple record versions and reconcile them

## Improving B-trees

The space overhead and write amplification of B-trees can be improved by using buffering. Generally, there are two ways of buffering:

1. Postpone propagating writes to disk and page splits
2. Make write operations sequential

## LSM Trees

LSM trees use buffering and append-only storage to achieve sequential writes. The word "merge" in LSM trees indicates that, due to their immutability, tree contents are merged using an approach similar to merge sort. This happens during maintenance to reclaim space occupied by redundant copies and garbage.

### Advantages of Immutability

- Keeping data files immutable favors sequential writes
- Since files are immutable, insert, update, and delete operations do not need locking, which significantly improves write performance
- Duplicate contents are allowed and conflicts are resolved during read time

### Components of LSM Trees

LSM trees consist of smaller memory-resident and larger disk-resident components:

1. **Memory-resident component (Memtable)**:

   - Mutable
   - Buffers data records
   - Serves as a target for read and write operations
   - Contents are persisted on disk when its size grows up to a configurable threshold
   - Updates incur no disk access and have no associated I/O cost
   - A separate write-ahead log file is required to guarantee durability of data records

2. **Disk-resident components**:
   - Built by flushing contents buffered in memory to disk
   - Used only for reads
   - Buffered contents are persisted, and files are never modified

### Operations in LSM Trees

- Insert, update, delete operations do not require locating data records
- Redundant records are reconciled during reads
- Deletes need to be recorded explicitly using special delete entries (sometimes called "tombstones" or "delete markers"), indicating removal of the data record associated with the specific key
- Since contents of disk-resident tables are sorted, we can use the multi-way merge sort algorithm

## Common LSM Tree Implementation Features

### Sorted String Tables (SSTables)

- Disk-resident tables are often implemented using SSTables
- Records in SSTables are sorted
- SSTables usually consist of two components:
  1. **Index files**: Implemented using structures allowing logarithmic lookups (B-trees) or constant-time lookups (hash tables)
  2. **Data files**: Hold records in key order
- Using a hash table for indexing doesn't prevent range scans, as the hash table is only accessed to locate the first key in the range

### Bloom Filters

- A space-efficient probabilistic data structure
- Used to test whether an element is a member of a set
- Can produce false positive matches but cannot produce false negatives
- In other words, a Bloom filter can tell if a key might be in the table or is definitely not in the table
- Used to prevent unnecessary table lookups

### Skip Lists

- A data structure for keeping sorted data in memory
- Becoming more popular recently due to its simplicity
- Offers probabilistic complexity guarantees close to those of search trees

# 第7章: ログ構造型ストレージ

## 会計のアナロジー

会計士が記録を修正する必要がある場合、既存の値を消去するのではなく、新しい記録を作成します。最終的な結果を得るには、記録を確認して小計を計算する必要があります。同様に、イミュータブル（不変）なストレージ構造は既存のファイルの修正を許可せず、代わりに新しい記録を追加します。

## ミュータブル vs イミュータブル構造

- **ミュータブル（インプレース更新）**: B木が典型的な例
- **イミュータブル（追記型）**: ログ構造、LSMツリー、Luceneツリーが例

## パフォーマンスのトレードオフ

### インプレース更新ストレージ構造

- 読み取りパフォーマンスに最適化
- ディスク上でデータを見つけた後、レコードをクライアントに返すことができる
- これは書き込みパフォーマンスを犠牲にしている
- データを更新するには、まずディスク上でレコードを見つける必要がある

### 追記型ストレージ

- 書き込みパフォーマンスに最適化
- 書き込みの際、上書きするためにディスク上のレコードを探す必要がない
- これは読み取りを犠牲にしており、複数のレコードバージョンを取得して調整する必要がある

## B木の改善

B木の空間オーバーヘッドと書き込み増幅は、バッファリングを使用することで改善できます。一般的に、バッファリングには2つの方法があります：

1. ディスクへの書き込みとページ分割の伝播を延期する
2. 書き込み操作をシーケンシャルにする

## LSMツリー

LSMツリーはバッファリングと追記型ストレージを使用して、シーケンシャルな書き込みを実現します。LSMツリーの「マージ」という言葉は、イミュータブルな性質により、ツリーの内容がマージソートに似たアプローチで結合されることを示しています。これはメンテナンス時に行われ、冗長なコピーとガベージが占める領域を再利用します。

### イミュータビリティの利点

- データファイルをイミュータブルに保つことでシーケンシャルな書き込みが可能
- ファイルがイミュータブルなため、挿入、更新、削除操作にロックが不要で、書き込みパフォーマンスが大幅に向上
- 重複したコンテンツが許容され、読み取り時に競合が解決される

### LSMツリーのコンポーネント

LSMツリーは、小さなメモリ常駐コンポーネントと大きなディスク常駐コンポーネントで構成されます：

1. **メモリ常駐コンポーネント（メムテーブル）**:

   - ミュータブル
   - データレコードをバッファリング
   - 読み取りと書き込み操作の対象
   - そのサイズが設定可能な閾値に達すると、内容はディスクに永続化される
   - 更新にはディスクアクセスが不要で、I/Oコストも発生しない
   - データレコードの耐久性を保証するために、別のWrite-Ahead Logファイルが必要

2. **ディスク常駐コンポーネント**:
   - メモリにバッファリングされた内容をディスクにフラッシュして構築
   - 読み取り専用
   - バッファリングされた内容は永続化され、ファイルは決して変更されない

### LSMツリーでの操作

- 挿入、更新、削除操作ではデータレコードの位置を特定する必要がない
- 冗長なレコードは読み取り時に調整される
- 削除は明示的に記録する必要があり、特定のキーに関連するデータレコードの削除を示す特別な削除エントリ（「墓石」や「削除マーカー」と呼ばれることもある）を挿入することで行われる
- ディスク常駐テーブルの内容はソートされているため、多方向マージソートアルゴリズムを使用できる

## LSMツリー実装の一般的な特徴

### ソート済み文字列テーブル（SSTable）

- ディスク常駐テーブルはSSTableを使用して実装されることが多い
- SSTableのレコードはソートされている
- SSTableは通常、2つのコンポーネントで構成される：
  1. **インデックスファイル**: 対数的な検索（B木）または定数時間の検索（ハッシュテーブル）を可能にする構造を使用して実装
  2. **データファイル**: キー順にレコードを保持
- インデックス作成にハッシュテーブルを使用しても範囲スキャンの実装は妨げられない。ハッシュテーブルは範囲内の最初のキーを見つけるためだけにアクセスされる

### ブルームフィルター

- 空間効率の良い確率的データ構造
- 要素がセットのメンバーであるかどうかをテストするために使用
- 偽陽性の一致を生成する可能性があるが、偽陰性は生成しない
- つまり、ブルームフィルターは、キーがテーブルに存在する可能性があるか、確実に存在しないかを判断できる
- 不要なテーブル検索を防ぐために使用される

### スキップリスト

- メモリ内でソートされたデータを保持するためのデータ構造
- シンプルさから最近より人気が高まっている
- 検索木に近い確率的な複雑性の保証を提供する
