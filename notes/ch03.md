# Chapter 3: File Formats

## Disk vs. Memory Access

- Unlike main memory access (which is mostly transparent), disk access uses system calls
- We must specify file offsets and interpret on-disk implementation into a form suitable for main memory
- Efficient on-disk structures must be designed with this distinction in mind

## Binary Formats

- Data needs to be encoded using formats that are compact and easy to serialize/deserialize
- The term "layout" is frequently used when discussing binary formats
- Instead of using `malloc` and `free`, we must think in terms of `read` and `write` operations and prepare data accordingly

## Data Types and Representations

- Keys and values have types (integer, date, string) represented in raw binary forms
- **Primitive numeric types**: Fixed size
- **Variable-sized data** (strings): Serialized as a length number followed by the actual data bytes
- **Booleans**: Represented by a single byte or encoded as 1 (true) and 0 (false)
- **Enums** (enumerated types): Represented as integers, commonly used in binary formats and communication protocols

## Page Structure

- Database systems store data in records and index files
- Data files are partitioned into large units called "pages"
- Pages often have a size of multiple file system blocks
- Pages are typically around 4-16 kilobytes

## Free Space Management

- Managing variable-size records presents challenges for free space management
- Need efficient methods for reclaiming space occupied by removed records
- For efficiently storing variable-sized data (strings, binaries, large objects), we can use the "slotted page" technique

## Slotted Page Technique

- Used by many databases including PostgreSQL
- Pages are organized into a collection of slots or cells
- Pointers and cells are split into independent memory regions on different sides of the page
- This approach means we only need to reorganize pointers
- Removing a record can be done by either nullifying its pointer or removing it

## Cell Structure

To compose a key cell, we need:

- Cell type
- Key size
- ID of the child page
- Key bytes

## Page Layout

- Using the slotted page technique:
  - Cells are appended to the right side of the page
  - Cell offset pointers are kept on the left side of the page

# 第3章：ファイル形式

## ディスクとメモリアクセスの違い

- メインメモリアクセス（ほとんど透過的）と異なり、ディスクアクセスはシステムコールを使用
- ファイルのオフセットを指定し、ディスク上の実装をメインメモリに適した形式に解釈する必要がある
- 効率的なディスク上の構造は、この区別を念頭に置いて設計する必要がある

## バイナリ形式

- データはコンパクトで簡単にシリアライズ/デシリアライズできる形式でエンコードする必要がある
- バイナリ形式について議論する際、「レイアウト」という用語がよく使用される
- `malloc`や`free`の代わりに、`read`と`write`操作で考え、それに応じてデータを準備する必要がある

## データ型と表現

- キーと値は型（整数、日付、文字列）を持ち、生のバイナリ形式で表現される
- **プリミティブな数値型**：固定サイズ
- **可変サイズデータ**（文字列）：長さを表す数値に続いて実際のデータバイトでシリアライズ
- **ブール値**：1バイトで表現、または1（真）と0（偽）としてエンコード
- **列挙型**（enum）：整数として表現され、バイナリ形式や通信プロトコルでよく使用される

## ページ構造

- データベースシステムはレコードとインデックスファイルにデータを格納
- データファイルは「ページ」と呼ばれる大きな単位に分割される
- ページは多くの場合、複数のファイルシステムブロックのサイズを持つ
- ページは通常4〜16キロバイト程度

## 空き領域管理

- 可変サイズレコードの管理は空き領域管理に課題をもたらす
- 削除されたレコードが占めていた領域を効率的に再利用する方法が必要
- 可変サイズデータ（文字列、バイナリ、ラージオブジェクト）を効率的に格納するために「スロットページ」技術を使用できる

## スロットページ技術

- PostgreSQLを含む多くのデータベースで使用されている
- ページはスロットまたはセルのコレクションとして編成される
- ポインタとセルはページの異なる側に存在する独立したメモリ領域に分割される
- このアプローチではポインタの再編成だけで済む
- レコードの削除は、そのポインタを無効化するか、削除することで実行できる

## セル構造

キーセルを構成するために必要なもの：

- セルタイプ
- キーサイズ
- 子ページのID
- キーバイト

## ページレイアウト

- スロットページ技術を使用：
  - セルはページの右側に追加される
  - セルオフセットポインタはページの左側に保持される
