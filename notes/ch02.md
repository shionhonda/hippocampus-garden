# Database Internals: Chapter 2 Notes - B-Tree Basics

## Storage Structures Overview

Storage structures can be grouped into two categories:

- **Mutable**: Use in-place update mechanisms
- **Immutable**: Create new versions instead of modifying existing data

Most mutable storage structures use an in-place update mechanism. During insert, delete, or update operations, they record changes directly in the target file locations. B-trees are one of the most popular data structures used in many open-source databases.

## Binary Search Trees vs B-Trees

Before diving into B-trees, let's understand why we should consider them over binary search trees.

### Binary Search Trees (BSTs)

A Binary Search Tree (BST) is a sorted in-memory data structure for key-value lookup. BSTs consist of multiple nodes, and each tree node contains:

- A key
- A value associated with the key
- Two child pointers

BSTs start from a single node called the root node. Each node splits the search space into left and right:

- The node key is greater than any key stored in its left subtree
- The node key is less than any key stored in its right subtree

By following the left pointer from the root down to leaf level, we can locate the node holding the smallest key in the tree and the value associated with it.

#### Limitations of BSTs

When insert operations do not follow any specific pattern, the tree can become unbalanced and look more like a linked list instead of a balanced tree, losing the desired logarithmic complexity.

This illustrates why trees need to be balanced. A balanced tree is defined as one that has a height of log₂(n), where n is the number of nodes. In an unbalanced tree, following the left or right node pointers might lead to worst-case linear complexity.

To keep the tree balanced, we need to rebalance after each modification. Balancing is done by reorganizing nodes in a way that keeps the number of nodes on each side within balance. One way to do this is to perform rotation steps after elements are added or removed.

Due to low fan-out (maximum number of children per node), we have to perform balancing, relocate nodes, and update pointers very frequently. This increases the maintenance cost of BSTs as on-disk data structures. Also, since elements are added in random order, there's no guarantee that a newly created node is physically close to its parent, which affects locality.

Binary trees have a fan-out of just two, requiring log₂(n) steps to locate a searched element and subsequently perform the same number of disk accesses.

### B-Trees: A Better On-Disk Alternative

A tree structure better suited for disk implementation needs:

- High fan-out to improve locality
- Low height to reduce the number of seeks during traversal

B-trees build upon the foundation of binary search trees but are better suited for disk-based storage.

## B-Tree Characteristics

- **Ordered Structure**: Keys inside B-tree nodes are stored in order, allowing binary search for lookups
- **Logarithmic Complexity**: Lookups in B-trees have logarithmic complexity
- **Query Support**: Effectively execute both point queries (equality predicates) and range queries (comparison predicates)
- **Node Structure**: Each node contains keys and n+1 pointers

Like binary search trees, B-trees have root nodes, leaf nodes, and internal nodes. Since B-trees are page-oriented, the terms "node" and "page" are often used interchangeably.

## B-Tree vs B+Tree

"B-tree" is an umbrella term for a family of data structures that share most of the mentioned properties. A more precise name for the commonly described data structure is "B+tree":

- **B-trees**: Allow storing values at any level, even in internal nodes
- **B+trees**: Store values only in leaf nodes; internal nodes store only keys

In B+trees, all operations affect only leaf nodes and propagate to higher levels only during splits and merges.

## Separator Keys and Tree Structure

Keys stored in B-tree nodes are called index entries, separator keys, or divider cells. They split the tree into subtrees holding corresponding key ranges:

- The first pointer in a node points to the subtree holding items less than the first key
- The last pointer points to the subtree holding items greater than or equal to the last key
- Other pointers reference subtrees between two keys

## B-Tree Lookup Complexity

B-tree lookup complexity can be viewed from two standpoints:

1. **Number of disk transfers**: Logarithmic with base n (number of keys per node)
2. **Number of comparisons**: Each node lookup uses binary search with log₂(n) complexity

During lookup, at most log_n(M) pages are accessed to find the search key (where M is the total number of keys and n is the number of keys per node).

In textbooks and articles, B-tree lookup complexity is generally referenced simply as O(log n).

## B-Tree Operations

### Search Algorithm

1. Start from the root and perform binary search
2. Find the first separator key greater than the searched value
3. Follow the corresponding pointer to the subtree
4. Continue the same search process until reaching the target leaf node

### Insertion

1. Locate the target leaf and find the insertion point using binary search
2. Append the key and value to the leaf
3. If the target node doesn't have enough room (overflow), split the node:
   - Allocate a new node
   - Transfer half the elements from the split node to the new one
   - Add the first key of the new node and a pointer to the parent (key promotion)

The tree height changes only when the root node is split and a new root is allocated, or when nodes are merged to form a new root. Otherwise, the tree only grows horizontally.

### Node Split Steps

1. Allocate the new node
2. Copy half the elements from the splitting node to the new one
3. Place the new element into the corresponding node
4. Add a separator key and a pointer to the new node in the parent of the split node

### Deletion

1. Locate the target leaf
2. Remove the key and associated value
3. If neighboring nodes have too few values (underflow), merge sibling nodes

### Node Merge Steps

1. Copy all elements from the right node to the left node
2. Remove the right node pointer from the parent
3. Remove the right node

# データベース内部構造: 第1章ノート - B木の基礎

## ストレージ構造の概要

ストレージ構造は2つのカテゴリーに分類できます：

- **可変（Mutable）**: インプレース更新メカニズムを使用
- **不変（Immutable）**: 既存データを修正する代わりに新しいバージョンを作成

ほとんどの可変ストレージ構造はインプレース更新メカニズムを使用しています。挿入、削除、更新操作の際、対象ファイルの場所に直接変更を記録します。B木は多くのオープンソースデータベースで使用される最も人気のあるデータ構造の一つです。

## 二分探索木とB木の比較

B木について詳しく説明する前に、なぜ二分探索木よりもB木を検討すべきかを理解しましょう。

### 二分探索木（BST）

二分探索木（BST）はキーと値の検索のための、ソートされたインメモリデータ構造です。BSTは複数のノードで構成され、各ツリーノードには以下が含まれます：

- キー
- キーに関連付けられた値
- 2つの子ポインタ

BSTは根（ルート）ノードと呼ばれる単一のノードから始まります。各ノードは検索空間を左右に分割します：

- ノードのキーは左部分木に格納されているどのキーよりも大きい
- ノードのキーは右部分木に格納されているどのキーよりも小さい

ルートから葉レベルまで左ポインタをたどることで、ツリー内の最小のキーを持つノードとそれに関連する値を見つけることができます。

#### BSTの制限

挿入操作が特定のパターンに従わない場合、ツリーはバランスが崩れ、バランスの取れたツリーではなくリンクリストのような形になり、望ましい対数的な複雑さを失います。

これはツリーがバランスを保つ必要がある理由を示しています。バランスの取れたツリーは、ノード数nに対して高さがlog₂(n)であるツリーとして定義されます。バランスの崩れたツリーでは、左右のノードポインタをたどると、最悪の場合、線形の複雑さになる可能性があります。

ツリーのバランスを保つためには、各変更後に再バランスを行う必要があります。バランシングは、各側のノード数をバランス内に保つ方法でノードを再編成することによって行われます。これを行う一つの方法は、要素が追加または削除された後に回転ステップを実行することです。

ファンアウト（ノードあたりの最大子ノード数）が低いため、バランシング、ノードの再配置、ポインタの更新を頻繁に行う必要があります。これにより、BSTをディスク上のデータ構造として維持するコストが増加します。また、要素がランダムな順序で追加されるため、新しく作成されたノードが親に物理的に近いという保証はなく、これはローカリティに影響します。

二分木のファンアウトはわずか2であるため、検索要素を特定するためにlog₂(n)ステップが必要であり、同じ数のディスクアクセスを実行する必要があります。

### B木：ディスク向けの優れた代替案

ディスク実装に適したツリー構造には以下が必要です：

- ローカリティを向上させるための高いファンアウト
- トラバーサル中のシーク数を減らすための低い高さ

B木は二分探索木の基盤の上に構築されていますが、ディスクベースのストレージにより適しています。

## B木の特徴

- **順序付き構造**: B木ノード内のキーは順序付けられて格納され、二分探索による検索が可能
- **対数的な複雑さ**: B木での検索は対数的な複雑さを持つ
- **クエリサポート**: ポイントクエリ（等価述語）とレンジクエリ（比較述語）の両方を効果的に実行
- **ノード構造**: 各ノードはキーとn+1個のポインタを含む

二分探索木と同様に、B木にはルートノード、リーフノード、内部ノードがあります。B木はページ指向であるため、「ノード」と「ページ」という用語は互換的に使用されることがあります。

## B木とB+木の違い

「B木」は、言及された特性のほとんどを共有するデータ構造のファミリーを包括する用語です。一般的に説明されるデータ構造のより正確な名前は「B+木」です：

- **B木**: 内部ノードを含む任意のレベルで値を格納できる
- **B+木**: 値はリーフノードにのみ格納し、内部ノードはキーのみを格納

B+木では、すべての操作はリーフノードにのみ影響し、分割と併合の際にのみ上位レベルに伝播します。

## セパレータキーとツリー構造

B木ノードに格納されているキーはインデックスエントリ、セパレータキー、または分割セルと呼ばれます。これらは対応するキー範囲を保持するサブツリーにツリーを分割します：

- ノード内の最初のポインタは、最初のキーよりも小さい項目を保持するサブツリーを指す
- 最後のポインタは、最後のキー以上の項目を保持するサブツリーを指す
- その他のポインタは、2つのキーの間のサブツリーを参照する

## B木の検索複雑性

B木の検索複雑性は2つの観点から見ることができます：

1. **ディスク転送の数**: nを底とする対数（nはノードあたりのキー数）
2. **比較の数**: 各ノード検索は二分探索を使用し、log₂(n)の複雑さを持つ

検索中、検索キーを見つけるために最大でlog_n(M)ページにアクセスします（ここでMは総キー数、nはノードあたりのキー数）。

教科書や論文では、B木の検索複雑性は一般的に単にO(log n)と表記されます。

## B木の操作

### 検索アルゴリズム

1. ルートから始めて二分探索を実行
2. 検索値より大きい最初のセパレータキーを見つける
3. 対応するポインタをたどってサブツリーに進む
4. 目的のリーフノードに到達するまで同じ検索プロセスを続ける

### 挿入

1. 二分探索を使用して目的のリーフと挿入ポイントを特定
2. キーと値をリーフに追加
3. 対象ノードに十分なスペースがない場合（オーバーフロー）、ノードを分割：
   - 新しいノードを割り当て
   - 分割ノードから要素の半分を新しいノードに転送
   - 新しいノードの最初のキーとポインタを親に追加（キーの昇格）

ツリーの高さは、ルートノードが分割されて新しいルートが割り当てられる場合、またはノードが併合されて新しいルートを形成する場合にのみ変化します。それ以外の場合、ツリーは水平方向にのみ成長します。

### ノード分割のステップ

1. 新しいノードを割り当てる
2. 分割ノードから要素の半分を新しいノードにコピーする
3. 新しい要素を対応するノードに配置する
4. 分割ノードの親に、セパレータキーと新しいノードへのポインタを追加する

### 削除

1. 目的のリーフを特定する
2. キーと関連する値を削除する
3. 隣接するノードの値が少なすぎる場合（アンダーフロー）、兄弟ノードを併合する

### ノード併合のステップ

1. 右ノードからすべての要素を左ノードにコピーする
2. 親から右ノードのポインタを削除する
3. 右ノードを削除する
