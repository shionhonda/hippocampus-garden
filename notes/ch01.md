# Database Internals: Chapter 1 - Introduction and Overview

## Part 1: Storage Engines

The primary function of any database management system is, of course, reliably storing data and making it available for users. Database management systems consist of multiple parts such as:

- A transport layer accepting requests
- Query processor determining the most efficient way to run queries
- Execution engine carrying out operations
- Storage engine

The storage engine is a software component of a database management system responsible for storing, retrieving, and managing data in memory and on disk. Designed to capture persistent, long-term storage of data, while databases can respond to complex queries, storage engines look at the more granular level and offer simple data manipulation, allowing users to create, update, and retrieve records.

Storage engines such as Berkeley DB, RocksDB, LevelDB, and many others were developed independently from database management systems. Using pluggable storage engines has enabled database developers to bootstrap database systems using existing storage engines and concentrate on other subsystems. At the same time, clear separation of database system components opens up an opportunity to switch between different engines potentially better suited for particular use cases. For example, MySQL has several storage engines, switching between InnoDB, in-memory, and MyISAM.

### Choosing the Right Database

Your choice of database system may have long-term consequences. Trying to compare databases based on the components can lead to invalid and premature conclusions. To compare databases, it's helpful to understand the use case in great detail and define current and expected variables such as:

- Schema and record sizes
- Number of clients
- Types of queries
- Access patterns
- Rates of reading/writing
- Expected changes in any of these variables

To select the right database, you should ask yourself:

- Does the database support the required queries?
- Is the database able to handle the amount of data we are planning to store?
- How many reading and writing operations can a single node handle?

If we could use databases as black boxes, it would be great. We would never have to look inside them, but in reality, that's not the case. Sooner or later we have a bug, an outage, performance regression, or some other problems. Perhaps it's better to be prepared - if you know and understand the internals, you can reduce business risk and improve chances for quick recovery.

## Chapter 1: Introduction and Overview

This chapter introduces some basic concepts and terminologies.

### OLTP vs OLAP

- **Online Transaction Processing (OLTP)** databases handle large numbers of user-facing requests and transactions. Queries are often predefined and short-lived.
- **Online Analytical Processing (OLAP)** databases handle complex aggregations to compute statistics. Queries are often complex, long-running, and ad hoc.

These are both databases, but they are very different. Every database is built slightly differently, and component boundaries are somewhat hard to see and define.

### Database Architecture

Database management systems use the client-server model, with database system instances taking the role of servers and application instances taking the role of clients:

1. Client request arrives through the transport layer
2. The transport system hands the query over to the query processor, which parses, interprets, and validates it
3. The parsed query is passed to the query optimizer, which:
   - Eliminates impossible and redundant parts of the query
   - Attempts to find the most efficient way to execute it based on internal statistics and data placement
4. The query is usually presented in the form of an execution plan or query plan - a set of operations that have to be carried out for the results to be considered complete
5. The execution plan is carried out by the execution engine, which aggregates the results of local and remote operations:
   - Remote executions can involve writing/reading data to and from other nodes in the cluster and replication
   - Local queries are executed by the storage engine

The storage engine has several components with dedicated responsibilities, such as:

- Transaction manager
- Lock manager
- Access methods
- Buffer manager
- Recovery manager

### Memory vs. Disk Storage

Database systems store data in memory and on disk. Accessing memory is several orders of magnitude faster than accessing disk, so it is tempting to use memory as the primary storage, and it becomes more economically feasible to do so as memory prices go down. However, RAM prices still remain high compared to persistent storage devices such as SSDs and HDDs, and also RAM is volatile, meaning lack of durability. Software errors, crashes, hardware failures, and power outages can all result in data loss. This situation is likely to change as the availability and popularity of non-volatile memory (NVM) technologies grow.

### Row-oriented vs. Column-oriented Storage

One of the ways to classify databases is by how the data is stored on disk: row-wise or column-wise.

**Row-oriented** database management systems include MySQL, PostgreSQL, and most traditional relational databases. The row-oriented approach works well for cases where several fields constitute the record uniquely identified by the key. Row-oriented stores are most useful in scenarios when we have to access entire rows together, improving spatial locality.

**Column-oriented** stores are a good fit for analytical workloads that compute aggregates such as finding trends, computing average values, etc. In the database, values belonging to the same column are stored closely together. Due to a rising demand to run complex analytical queries on growing data sets, we've seen many new column-oriented file formats, such as Parquet, ORC file, etc.

**Wide column stores** such as BigTable or HBase, data is represented as a multidimensional map and columns are grouped into column families, and inside each column family, data is stored row-wise. This layout is best for storing data retrieved by a key or sequence of keys.

## Database Storage Fundamentals

- Databases use files for data storage, **not** relying on file system hierarchies.
- Data records consist of multiple fields, organized in tables (separate files).
- Records are locatable via search keys; indexes are used for efficient lookup (avoiding full table scans).
- Data files and index files are usually separated.
- Files are partitioned into pages, sized as single/multiple disk blocks.
  - Pages organized as record sequences or slotted pages.
- Records represented as key-value pairs.
- Deletion handled via deletion markers/tombstones (key, timestamp).
- Space reclaimed via garbage collection.
- Data files: indexed, heap, or hash organized tables.

## Indexing and Storage Engines

- **Index**: structure facilitating efficient retrieval, no inherent data organization
  - Primary index: index on primary data file, often primary key
  - Secondary indexes: point to data record (offset to heap file/index organized table) or primary key
- **Index-organized table**: data records stored directly in index file
  - Alternative: index file stores offsets, separate file stores data records.
- Storage engine based on data structure.

  - Common variables: buffering, immutable files, ordered values.
  - Buffering: collect data in memory before writing to disk
  - Mutability: in-place updates vs. append-only (immutable)
  - Copy-on-write: modified page written to new location.
  - LSM and B-trees: distinction drawn as immutable vs in-place, but immutable structures inspired by B-trees exist
  - Ordering: data records stored in key order on disk, allowing efficient range scans.
  - Unordered data allows write time optimizations (e.g., BitCask, Whiskey - store records in append-only files)

# データベース内部構造: 第1章 - はじめにと概要

## パート1: ストレージエンジン

データベース管理システムの主な機能は、もちろんデータを確実に保存し、ユーザーが利用できるようにすることです。データベース管理システムは以下のような複数の部分で構成されています：

- リクエストを受け付けるトランスポート層
- クエリを実行する最も効率的な���法を決定するクエリプロセッサ
- 操作を実行する実行エンジン
- ストレージエンジン

ストレージエンジンは、データベース管理システムのソフトウェアコンポーネントであり、メモリとディスク上のデータの保存、取得、管理を担当します。永続的な長期データストレージを実現するよう設計されており、データベースが複雑なクエリに応答できる一方、ストレージエンジンはより細かいレベルで見て、ユーザーがレコードの作成、更新、取得を行えるようにする単純なデータ操作を提供します。

Berkeley DB、RocksDB、LevelDBなどのストレージエンジンは、データベース管理システムとは独立して開発されました。プラグイン可能なストレージエンジンを使用することで、データベース開発者は既存のストレージエンジンを活用してデータベースシステムを構築し、他のサブシステムに集中することができます。同時に、データベースシステムコンポーネントを明確に分離することで、特定のユースケースにより適したエンジンに切り替える機会が生まれます。例えば、MySQLには複数のストレージエンジンがあり、InnoDB、インメモリ、MyISAMの間で切り替えることができます。

### 適切なデータベースの選択

データベースシステムの選択は長期的な影響を持つ可能性があります。コンポーネントに基づいてデータベースを比較しようとすると、無効で早計な結論に至る可能性があります。データベースを比較するには、ユースケースを詳細に理解し、以下のような現在および予想される変数を定義することが役立ちます：

- スキーマとレコードサイズ
- クライアント数
- クエリの種類
- アクセスパターン
- 読み書きの頻度
- これらの変数の予想される変化

適切なデータベースを選択するには、以下のような質問をする必要があります：

- データベースは必要なクエリをサポートしていますか？
- データベースは保存しようとしているデータ量を処理できますか？
- 単一ノードで処理できる読み書き操作の数はどれくらいですか？

データベースをブラックボックスとして使用できれば素晴らしいでしょう。内部を見る必要はないでしょうが、現実にはそうではありません。遅かれ早かれ、バグ、停止、パフォーマンス低下、その他の問題が発生します。内部構造を知り理解していれば、ビジネスリスクを軽減し、迅速な復旧の可能性を高めることができるでしょう。

## 第1章：はじめにと概要

この章では、いくつかの基本的な概念と用語を紹介します。

### OLTPとOLAP

- **オンライントランザクション処理（OLTP）**データベースは、多数のユーザー向けリクエストとトランザクションを処理します。クエリは多くの場合、事前に定義され、短時間で終了します。
- **オンライン分析処理（OLAP）**データベースは、統計を計算するための複雑な集計を処理します。クエリは多くの場合、複雑で、長時間実行され、アドホックです。

これらはどちらもデータベースですが、非常に異なります。すべてのデータベースは少しずつ異なる方法で構築されており、コンポーネントの境界は多少見えにくく、定義しにくいものです。

### データベースアーキテクチャ

データベース管理システムはクライアント-サーバーモデルを使用し、データベースシステムインスタンスがサーバーの役割を、アプリケーションインスタンスがクライアントの役割を担います：

1. クライアントリクエストがトランスポート層を通じて到着
2. トランスポートシステムはクエリをクエリプロセッサに渡し、クエリプロセッサはそれを解析、解釈、検証します
3. 解析されたクエリはクエリオプティマイザに渡され、以下が行われます：
   - クエリの不可能な部分や冗長な部分を排除
   - 内部統計とデータ配置に基づいて、最も効率的な実行方法を見つけようとする
4. クエリは通常、実行計画またはクエリ計画の形で表されます - 結果が完了と見なされるために実行される必要がある一連の操作
5. 実行計画は実行エンジンによって実行され、ローカルおよびリモート操作の結果を集約します：
   - リモート実行には、クラスター内の他のノードとのデータの読み書きやレプリケーションが含まれる場合があります
   - ローカルクエリはストレージエンジンによって実行されます

ストレージエンジンには、以下のような専用の責任を持つ複数のコンポーネントがあります：

- トランザクションマネージャ
- ロックマネージャ
- アクセスメソッド
- バッファマネージャ
- リカバリマネージャ

### メモリ vs. ディスクストレージ

データベースシステムはメモリとディスクにデータを保存します。メモリへのアクセスはディスクへのアクセスより数桁速いため、メモリを主要なストレージとして使用することは魅力的であり、メモリ価格が下がるにつれて経済的にも実現可能になってきています。しかし、RAMの価格はSSDやHDDなどの永続的なストレージデバイスと比較するとまだ高く、またRAMは揮発性であり、耐久性に欠けます。ソフトウェアエラー、クラッシュ、ハードウェア障害、電源障害などはすべてデータ損失につながる可能性があります。不揮発性メモリ（NVM）技術の普及と人気が高まるにつれて、この状況は変わる可能性があります。

### 行指向 vs. 列指向ストレージ

データベースを分類する方法の一つは、ディスク上でのデータの保存方法です：行単位または列単位。

**行指向**データベース管理システムには、MySQL、PostgreSQL、ほとんどの従来のリレーショナルデータベースが含まれます。行指向アプローチは、キーによって一意に識別されるレコードが複数のフィールドで構成される場合に適しています。行指向ストアは、行全体に一緒にアクセスする必要がある場合に最も有用であり、空間的局所性を向上させます。

**列指向**ストアは、傾向の発見、平均値の計算など、集計を計算する分析ワークロードに適しています。データベースでは、同じ列に属する値が近くに保存されます。増大するデータセットに対して複雑な分析クエリを実行する需要の高まりにより、Parquet、ORCファイルなど、多くの新しい列指向ファイル形式が登場しています。

**ワイドカラムストア**（BigTableやHBaseなど）では、データは多次元マップとして表現され、列はカラムファミリーにグループ化され、各カラムファミリー内ではデータは行単位で保存されます。このレイアウトは、キーまたはキーのシーケンスによって取得されるデータを保存するのに最適です。

## データベースストレージの基本

- データベースはデータストレージにファイルを使用し、ファイルシステム階層に**依存しません**。
- データレコードは複数のフィールドで構成され、テーブル（別々のファイル）に整理されます。
- レコードは検索キーによって特定可能です；インデックスは効率的な検索（完全テーブルスキャンを避ける）に使用されます。
- データファイルとインデックスファイルは通常分離されています。
- ファイルはページに分割され、単一または複数のディスクブロックサイズになっています。
  - ページはレコードシーケンスまたはスロットページとして整理されます。
- レコードはキーと値のペアとして表現されます。
- 削除は削除マーカー/トゥームストーン（キー、タイムスタンプ）によって処理されます。
- スペースはガベージコレクションによって回収されます。
- データファイル：インデックス付き、ヒープ、またはハッシュ編成テーブル。

## インデックス作成とストレージエンジン

- **インデックス**：効率的な検索を容易にする構造、固有のデータ編成はありません
  - プライマリインデックス：プライマリデータファイル上のインデックス、多くの場合プライマリキー
  - セカンダリインデックス：データレコード（ヒープファイル/インデックス編成テーブルへのオフセット）またはプライマリキーを指す
- **インデックス編成テーブル**：データレコードがインデックスファイルに直接保存される
  - 代替：インデックスファイルがオフセットを保存し、別のファイルがデータレコードを保存する
- ストレージエンジンはデータ構造に基づいています
  - 共通変数：バッファリング、不変ファイル、順序付き値
  - バッファリング：ディスクに書き込む前にメモリ内にデータを収集
  - 可変性：インプレース更新 vs. 追加のみ（不変）
  - コピーオンライト：変更されたページが新しい場所に書き込まれる
  - LSMとBツリー：不変 vs. インプレースとして区別されるが、Bツリーに触発された不変構造も存在する
  - 順序付け：データレコードがディスク上でキー順に保存され、効率的な範囲スキャンを可能にする
  - 順序なしデータは書き込み時間の最適化を可能にする（例：BitCask、Whiskey - 追加専用ファイルにレコードを保存）
