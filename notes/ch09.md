# Chapter 9: Failure Detection

## Failure Detector Overview

A failure detector is a local subsystem responsible for identifying failed or unreachable processes to exclude them from the algorithm, guaranteeing liveness while preserving safety.

- **Liveness**: A property that generally guarantees that a specific intended action eventually takes place
- **Safety**: Guarantees that unintended events will not occur

## Essential Properties

Failure detection algorithms should exhibit several essential properties:

- Every non-faulty member should eventually notice process failures
- The algorithm should be able to make progress and eventually reach its final result
- This property is called **completeness**

## Detection Methods

We can track the state of remote processes by triggering one of two periodic processes:

1. **Ping**:

   - Sends messages to remote processes
   - Checks if they are still alive by expecting a response within a specified time period

2. **Heartbeat**:
   - Process actively notifies its peers that it's still running
   - Sends messages to peers periodically

## Timeout-Free Detection

Some algorithms avoid relying on timeouts for detecting failures:

- A **timeout-free failure detector** is an algorithm that only counts heartbeats
- Allows the application to detect process failures based on the data in the heartbeats

## Fine-Grained Failure Detection

Instead of treating node failures as a binary problem (up or down), a **φ-accurate failure detector** has a continuous scale capturing the probability of the monitored process crash.

It works by:

- Maintaining a sliding window, collecting arrival times of the most recent heartbeats from peer processes
- Using this information to approximate arrival time of the next heartbeat
- Comparing this approximation with the actual arrival time
- Computing the suspicion level (φ) - how certain the failure detector is about the failure given the current network conditions

## Gossip-Style Failure Detection

Another approach that avoids relying on a single node's view to make a decision:

- Uses gossip to collect and distribute state of neighboring processes
- Allows detection of both crashed nodes and nodes that are unreachable by any other cluster member

# 第9章：障害検出

## 障害検出器の概要

障害検出器は、アルゴリズムから除外すべき障害のあるプロセスや到達不能なプロセスを特定し、安全性を保ちながら活性を保証するためのローカルサブシステムです。

- **活性（Liveness）**：特定の意図されたアクションが最終的に発生することを一般的に保証するプロパティ
- **安全性（Safety）**：意図しないイベントが発生しないことを保証するプロパティ

## 必須特性

障害検出アルゴリズムは、いくつかの重要な特性を持つべきです：

- すべての正常なメンバーが最終的にプロセスの障害に気づくこと
- アルゴリズムが進行でき、最終的に最終結果に到達できること
- この特性は**完全性（completeness）**と呼ばれる

## 検出方法

リモートプロセスの状態を追跡するには、次の2つの定期的なプロセスのいずれかをトリガーします：

1. **ピング**：

   - リモートプロセスにメッセージを送信
   - 指定された時間内に応答を期待することで、プロセスが生きているかを確認

2. **ハートビート**：
   - プロセスが��らまだ稼働中であることをピアに積極的に通知
   - 定期的にピアにメッセージを送信

## タイムアウトに依存しない検出

障害検出にタイムアウトに依存しないアルゴリズムもあります：

- **タイムアウトフリー障害検出器**はハートビートのみをカウントするアルゴリズム
- ハートビート内のデータに基づいてプロセスの障害を検出可能

## 細粒度障害検出

ノードの障害を単に二つの状態（稼働中または停止中）として扱うのではなく、**φ精度障害検出器**は監視対象プロセスのクラッシュ確率を連続的なスケールで捉えます。

動作原理：

- ピアプロセスからの最新のハートビート到着時間を収集するスライディングウィンドウを維持
- この情報を使用して次のハートビートの到着時間を予測
- この予測と実際の到着時間を比較
- 疑惑レベル（φ）を計算 - 現在のネットワーク状況を考慮して、障害検出器が障害についてどの程度確信しているか

## ゴシップスタイル障害検出

単一ノードの視点に依存せずに判断を下すもう一つのアプローチ：

- 近隣プロセスの状態を収集・配布するためにゴシッププロトコルを使用
- クラッシュしたノードと他のクラスタメンバーから到達不能なノードの両方を検出可能
