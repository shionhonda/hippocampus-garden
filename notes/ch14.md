# Chapter 14: Consensus

## Consensus Algorithms in Distributed Systems

Consensus algorithms allow multiple processes to reach an agreement on a value. The FLP impossibility theorem shows that it is impossible to guarantee consensus in a completely asynchronous system in bounded time. Even if message delivery is guaranteed, it is impossible for one process to know whether another has crashed or is running slowly.

Consensus is extremely useful for:

- Putting events in a particular order
- Ensuring consistency among participants

Using consensus, we get a system where processes move from one value to the next without losing certainty about which value is current for the observer.

From a theoretical perspective, consensus algorithms have three properties:

1. Agreement
2. Validity
3. Termination

## Broadcast Algorithms

Broadcast algorithms are used to disseminate information among a set of processes. They are often used for database replication when a single coordinating node has to distribute data to all other participants. Making this process reliable is not trivial.

### Best Effort Broadcast

The simplest way to broadcast messages is through best effort broadcast. In this case, the sender is responsible for ensuring message delivery to all targets. If it fails, the other passive nodes do not try to rebroadcast the message. In the case of coordinator crash, this type of broadcast will fail silently.

### Reliable Broadcast

For broadcast to be reliable, it needs to guarantee that all correct processes receive the same messages even if the sender crashes during transmission. To implement a reliable broadcast, we can use a failure detector and a fallback mechanism.

The most straightforward fallback mechanism is to allow every process that receives the message to forward it to every other process. One downside of this approach is that it uses n-squared messages, which is not ideal.

### Atomic Broadcast

If we need to deliver messages in order, we have to use Atomic Broadcast, which guarantees both reliable delivery and total order. Atomic broadcast ensures:

- Atomicity: every message is either delivered to all processes or none
- Order: messages are delivered in the same order to all processes

## Virtual Synchrony

Virtual synchrony is a framework for group communication using broadcast. While atomic broadcast helps deliver totally ordered messages, virtual synchrony delivers totally ordered messages to a dynamic group of peers.

Virtual synchrony:

- Organizes processes into groups
- As long as the group exists, messages are delivered to all members in the same order
- When a participant joins, leaves, or fails, the group view changes
- Group changes are announced to all members

## Zookeeper Atomic Broadcast (ZAB)

One of the most popular and widely known implementations of atomic broadcast is ZAB, used by ZooKeeper. ZooKeeper is a hierarchical distributed key-value store where ZAB is used to ensure total order of events and atomic delivery necessary to maintain consistency.

Processes in ZAB can take one of two roles:

- **Leader**: A temporary role that drives the process by executing algorithm steps, broadcasts messages to followers, and establishes event order with unique monotonically increasing identifiers
- **Follower**: Receives and processes messages from the leader

To guarantee leader uniqueness, the protocol timeline is split into epochs, each identified by a unique number. During any epoch, there can be only one leader.

The protocol operates in three phases:

1. **Discovery**: The prospective leader learns about the latest epoch known by every other process and proposes a new epoch that is greater than the current epoch of any follower. Followers respond to the proposal with information about their latest transactions.
2. **Synchronization**: This phase is used to recover and bring lagging followers up to speed.
3. **Broadcast**: As soon as followers are in sync, active messaging starts. During this phase, the leader receives client messages, establishes the order, and broadcasts them to followers.

Advantages of ZAB:

- Efficiency: The broadcast process requires only two rounds of messages
- Leader failures can be recovered by streaming missing messages from a single up-to-date process
- Having a long-lived leader has a positive impact on performance as it doesn't require additional complex rounds to establish event history

## Paxos

Participants in Paxos can take one of three roles:

- **Proposers**: Receive values from clients, create proposals to accept these values, and attempt to collect votes from acceptors
- **Acceptors**: Vote to accept or reject the values proposed by the proposer
- **Learners**: Take the role of replicas, storing the outcome of the protocol

For fault tolerance, the algorithm requires multiple acceptors, but only a quorum of acceptor votes is required to accept a proposal.

The Paxos algorithm can be generally split into two phases:

1. Voting
2. Replication

**Quorums** are used to ensure that some participants can fail while still allowing the system to proceed as long as votes can be collected from the alive ones. A quorum is the minimum number of votes required for an operation to be performed, usually consisting of a majority of participants.

The main idea behind quorums is to make sure that in case of network partition, there is at least one participant that acts as an arbiter ensuring protocol correctness.

One failure scenario is when a proposal succeeds during the second phase but before it can broadcast the value to all acceptors. In this case, a new proposer may pick up and commit the value, distributing it to the remaining participants.

## RAFT

Paxos was the consensus algorithm of choice for over a decade but was known as difficult to understand and implement. In 2013, a new algorithm called Raft appeared, designed to be easier to understand and implement.

In Raft, participants store logs containing sequences of commands executed by the state machine. A leader coordinates state machine manipulation and replication.

Each participant in Raft can take one of three roles:

- **Candidate**: To become a leader, a node first transitions into a candidate state and solicits votes from the majority of nodes
- **Leader**: A temporary cluster leader elected for a period called a term (identified by monotonically increasing numbers)
- **Follower**: A passive participant that persists log entries and responds to requests from leaders and candidates (similar to Acceptor and Learner in Paxos)

If multiple followers decide to become candidates, and no candidate can collect a majority of votes, Raft uses randomized timers to reduce the probability of split votes.

The Raft algorithm provides these guarantees:

- Only one leader can be elected at a time for a given term
- No two leaders can be elected for the same term
- The leader does not remove or reorder log contents, only appends new messages
- Committed log entries are preserved
- All messages are identified uniquely by message and term IDs
- Neither current nor subsequent leaders can reuse the same identifier

Since its appearance, Raft has become very popular in distributed systems implementations.
